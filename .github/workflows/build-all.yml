name: build-wheels

on:
  push:
    branches: [ main ]
    tags:
      - "v*"
  pull_request:
  workflow_dispatch:
    inputs:
      tag:
        description: "Package tag for validation (e.g., v1.0.12)"
        required: false
        default: ""

permissions:
  contents: write

jobs:
  bump-version:
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.out.outputs.commit_sha }}
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Bump CMake version from tag (if tagged)
        id: bump
        shell: bash
        env:
          IS_TAG: ${{ startsWith(github.ref, 'refs/tags/') }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          if [ "$IS_TAG" != "true" ]; then
            echo "Not a tag event; skipping version bump."
            exit 0
          fi
          TAG="$REF_NAME"
          # Validate tag format vX.Y or vX.Y.Z or similar
          if ! echo "$TAG" | grep -Eq '^v[0-9]+(\.[0-9]+)*$'; then
            echo "Invalid tag format: $TAG (expected v<semver>, e.g., v1.0.12)" >&2
            exit 1
          fi
          NEW_VER="${TAG#v}"
          # Switch to default branch (assumes main) and update there
          git fetch origin main
          git checkout -B main origin/main
          export NEW_VER
          python3 - << 'PY'
import re, io, os, sys
fn = 'CMakeLists.txt'
txt = io.open(fn, 'r', encoding='utf-8').read()
m = re.search(r"project\s*\(\s*tas_client_api[\s\S]*?VERSION\s*([0-9]+(?:\.[0-9]+)*)", txt, re.I|re.S)
if not m:
    print('VERSION not found in CMakeLists.txt', file=sys.stderr)
    sys.exit(1)
old = m.group(1)
new = os.environ.get('NEW_VER')
if not new:
    print('NEW_VER not set', file=sys.stderr)
    sys.exit(1)
if old == new:
    print('Version already up-to-date:', new)
    sys.exit(0)
new_txt = re.sub(r"(project\s*\(\s*tas_client_api[\s\S]*?VERSION\s*)([0-9]+(?:\.[0-9]+)*)", r"\g<1>"+new, txt, flags=re.I|re.S)
io.open(fn, 'w', encoding='utf-8').write(new_txt)
print(f'Bumped version: {old} -> {new}')
PY
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet -- CMakeLists.txt; then
            git add CMakeLists.txt
            git commit -m "chore(ci): bump version to ${NEW_VER} from tag"
            git push origin HEAD:main
          else
            echo "No version change to commit."
          fi
      - name: Output bumped commit SHA
        id: out
        run: |
          SHA=$(git rev-parse HEAD || echo "")
          echo "commit_sha=$SHA" >> $GITHUB_OUTPUT

  prepare:
    runs-on: ubuntu-latest
    outputs:
      versions: ${{ steps.out.outputs.versions }}
      version: ${{ steps.out.outputs.version }}
      short_sha: ${{ steps.out.outputs.short_sha }}
      ref: ${{ steps.out.outputs.ref }}
    needs: bump-version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Use bumped commit when tag push; otherwise the triggering SHA
          ref: ${{ needs.bump-version.outputs.commit_sha != '' && needs.bump-version.outputs.commit_sha || github.sha }}

      - name: Compute outputs (versions, version, short_sha)
        id: out
        run: |
          set -euo pipefail
          VERS=$(jq -c '.' .github/python-versions.json)
          echo "versions=$VERS" >> $GITHUB_OUTPUT
          if [ "${{ startsWith(github.ref, 'refs/tags/') }}" = "true" ]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION=$(python3 -c "import re,sys,io; s=io.open('CMakeLists.txt','r',encoding='utf-8').read(); m=re.search(r'project\\s*\\(\\s*tas_client_api[\\s\\S]*?VERSION\\s*([0-9]+(?:\\.[0-9]+)*)', s, re.IGNORECASE|re.DOTALL); print(m.group(1)) if m else sys.exit('VERSION not found in CMakeLists.txt')")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          SHORT_SHA=$(git rev-parse --short=7 HEAD)
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          REF=$(git rev-parse HEAD)
          echo "ref=$REF" >> $GITHUB_OUTPUT

  build-manylinux:
    needs: prepare
    runs-on: ubuntu-latest
    env:
      PKG_VERSION: ${{ needs.prepare.outputs.version }}
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
    strategy:
      matrix:
        py_ver: ${{ fromJSON(needs.prepare.outputs.versions) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Pull manylinux image
        run: docker pull quay.io/pypa/manylinux2014_x86_64

      - name: Build wheels in manylinux
        run: |
          docker run --rm -v $PWD:/work -w /work quay.io/pypa/manylinux2014_x86_64 /bin/bash -lc '
            set -euo pipefail
            PV="${{ matrix.py_ver }}"
            PTAG=$(echo "$PV" | tr -d '.')
            PYBIN=/opt/python/cp${PTAG}-cp${PTAG}/bin/python
            export PIP_ROOT_USER_ACTION=ignore
            $PYBIN -m pip install --upgrade pip
            $PYBIN -m pip install cmake ninja pybind11 setuptools wheel auditwheel
            export MANPATH=${MANPATH-""}
            set +u
            if [ -f /opt/rh/devtoolset-10/enable ]; then source /opt/rh/devtoolset-10/enable; elif [ -f /opt/rh/devtoolset-9/enable ]; then source /opt/rh/devtoolset-9/enable; fi
            set -u
            export PATH="$(dirname "$PYBIN"):$PATH"
            P11_DIR=$($PYBIN -c "import pybind11,sys; print(pybind11.get_cmake_dir())")
            BUILD_DIR=/work/build-cp${PTAG}
            cmake -S /work -B ${BUILD_DIR} -G Ninja -DCMAKE_BUILD_TYPE=Release -DTAS_CLIENT_API_BUILD_PYTHON=ON -DPython_EXECUTABLE=$PYBIN -Dpybind11_DIR="$P11_DIR"
            cmake --build ${BUILD_DIR} --target python_package -j"$(nproc)"
            mkdir -p /work/dist
            auditwheel repair -w /work/dist ${BUILD_DIR}/python/dist/*.whl || true
          '

      - name: Upload internal wheel + so (manylinux)
        uses: actions/upload-artifact@v4
        with:
          name: _tmp-PyTAS-${{ env.PKG_VERSION }}.${{ env.SHORT_SHA }}-${{ matrix.py_ver }}-linux
          retention-days: 1
          compression-level: 0
          path: |
            dist/*.whl
            build-*/python/src/PyTAS/*.so

  build-windows:
    needs: prepare
    runs-on: windows-latest
    env:
      PKG_VERSION: ${{ needs.prepare.outputs.version }}
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
    strategy:
      matrix:
        python-version: ${{ fromJSON(needs.prepare.outputs.versions) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          architecture: x64

      - name: Install build dependencies (CMake, Ninja, pybind11)
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install cmake ninja pybind11 wheel setuptools

      - name: Export pybind11 CMake dir
        id: p11
        shell: pwsh
        run: |
          $p11 = python -c "import pybind11; print(pybind11.get_cmake_dir())"
          echo "P11_DIR=$p11" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Configure CMake (Windows, Release)
        shell: pwsh
        run: |
          cmake -S . -B build-windows -G "Visual Studio 17 2022" -A x64 -DCMAKE_BUILD_TYPE=Release -DTAS_CLIENT_API_BUILD_PYTHON=ON -Dpybind11_DIR="$env:P11_DIR"

      - name: Build Python wheel via CMake target
        shell: pwsh
        run: |
          cmake --build build-windows --target python_package --config Release -- /m

      - name: Upload internal wheel + pyd (windows)
        uses: actions/upload-artifact@v4
        with:
          name: _tmp-PyTAS-${{ env.PKG_VERSION }}.${{ env.SHORT_SHA }}-${{ matrix.python-version }}-windows
          retention-days: 1
          compression-level: 0
          path: |
            build-windows/python/dist/*.whl
            build-windows/python/src/PyTAS/*.pyd

  collect:
    needs: [prepare, build-manylinux, build-windows]
    runs-on: ubuntu-latest
    env:
      PKG_VERSION: ${{ needs.prepare.outputs.version }}
      SHORT_SHA: ${{ needs.prepare.outputs.short_sha }}
      PKG_TAG: ${{ github.event.inputs.tag != '' && github.event.inputs.tag || (startsWith(github.ref, 'refs/tags/') && github.ref_name || github.sha) }}
    steps:
      - name: Validate tag matches project version
        if: startsWith(github.ref, 'refs/tags/') || github.event.inputs.tag != ''
        run: |
          TAG="${{ env.PKG_TAG }}"
          VER="${{ env.PKG_VERSION }}"
          if [ "$TAG" = "v$VER" ] || [ "$TAG" = "$VER" ]; then
            echo "Tag $TAG matches version $VER"
          else
            echo "Error: Tag $TAG does not match version $VER" >&2
            exit 1
          fi

      - name: Download internal manylinux artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: _tmp-PyTAS-${{ env.PKG_VERSION }}.${{ env.SHORT_SHA }}-*-linux
          merge-multiple: true
          path: artifacts/manylinux

      - name: Download internal windows artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: _tmp-PyTAS-${{ env.PKG_VERSION }}.${{ env.SHORT_SHA }}-*-windows
          merge-multiple: true
          path: artifacts/windows

      - name: Assemble dist folder
        run: |
          mkdir -p dist
          find artifacts -name '*.whl' -exec cp {} dist \;
          find artifacts -name '*.pyd' -exec cp {} dist \;
          find artifacts -name '*.so' -exec cp {} dist \;
          echo "Collected files:" && ls -la dist

      - name: Compute final artifact name (tagged vs untagged)
        run: |
          if [ "${{ startsWith(github.ref, 'refs/tags/') }}" = "true" ]; then
            echo "ARTIFACT_NAME=PyTAS-${PKG_VERSION}" >> $GITHUB_ENV
          else
            echo "ARTIFACT_NAME=PyTAS-${PKG_VERSION}.${SHORT_SHA}" >> $GITHUB_ENV
          fi

      - name: Upload combined artifact (wheels + pyd + so)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: dist
